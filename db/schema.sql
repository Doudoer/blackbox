-- Tabla de Perfiles (extiende auth.users)
create table profiles (
  id uuid primary key,
  username text unique not null,
  bio text,
  avatar_url text,
  is_admin boolean default false
);

-- Tabla de Mensajes (para chat one-to-one)
create table messages (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now(),
  sender_id uuid references profiles(id) on delete cascade,
  receiver_id uuid references profiles(id) on delete cascade,
  content text,
  image_url text,
  sticker_url text,
  message_type text default 'text' check (message_type in ('text', 'image', 'sticker'))
);

-- Índices
create index idx_messages_sender_receiver on messages(sender_id, receiver_id);
create index idx_messages_created_at on messages(created_at desc);

-- Habilitar Realtime (ejecutar en Supabase SQL editor si aplica)
-- alter publish supabase_realtime add table messages;

-- Row Level Security
alter table profiles enable row level security;
alter table messages enable row level security;

create policy "Users can view own profile" on profiles for select using (auth.uid() = id);
create policy "Users can update own profile" on profiles for update using (auth.uid() = id);

create policy "Users can view messages in conversation" on messages for select using (auth.uid() = sender_id or auth.uid() = receiver_id);
create policy "Users can insert messages" on messages for insert with check (auth.uid() = sender_id);

-- Nota: Eliminado trigger que dependía de auth.users. Ahora los perfiles se crean directamente
-- insertando en `profiles` (sin depender de auth.users). Usa el script `scripts/create_test_users.js`
-- o llamadas admin para insertar perfiles y establecer contraseñas con `public.set_user_password`.

-- Tabla separada para datos sensibles relacionados con la autenticación
-- MOTIVO: No recomendamos almacenar hashes de contraseña o flags de bloqueo en la tabla `profiles`
-- que es fácilmente consultable por el cliente. En su lugar, guardamos esos campos en
-- `profiles_secure` y NO creamos políticas de SELECT para esa tabla. El service role
-- de Supabase (clave de servidor) puede acceder a esta tabla y realizar cambios seguros
-- (p. ej., bloquear cuentas, comprobar hash en una función server-side, etc.).

-- Añadir campos sensibles directamente en la tabla `profiles`.
-- NOTA: Aunque están en la misma tabla, se recomienda que el cliente use la vista
-- `profiles_public` que excluye los campos sensibles. Las funciones server-side usan
-- `profiles` para verificar/establecer contraseñas.

alter table public.profiles
  add column if not exists password_hash text,
  add column if not exists pass_blocked boolean default false not null,
  add column if not exists failed_attempts integer default 0 not null,
  add column if not exists last_failed_at timestamptz;
  
-- Añadir campo para la clave de bloqueo de la app (hash)
alter table public.profiles
  add column if not exists lock_key_hash text;

-- Vista pública que excluye campos sensibles (usar desde el cliente)
create or replace view public.profiles_public as
select id, username, bio, avatar_url, is_admin
from public.profiles;

-- Helpers para hashing/verificación (usa pgcrypto). Ejecutar en Supabase SQL (pgcrypto debe estar disponible).
create extension if not exists pgcrypto;

-- Establecer password (genera bcrypt hash usando gen_salt('bf'))
create or replace function public.set_user_password(p_user_id uuid, p_password text) returns void language plpgsql security definer as $$
begin
  update public.profiles
  set password_hash = crypt(p_password, gen_salt('bf')),
      pass_blocked = false,
      failed_attempts = 0,
      last_failed_at = null
  where id = p_user_id;
end;
$$;

-- Verificar password por username. Retorna el user id si coincide, NULL si falla.
create or replace function public.verify_user_password(p_username text, p_password text) returns uuid language plpgsql security definer as $$
declare
  uid uuid;
  stored text;
begin
  select id into uid from public.profiles where username = p_username;
  if uid is null then
    return null;
  end if;

  select password_hash into stored from public.profiles where id = uid;
  if stored is null then
    return null;
  end if;

  if stored = crypt(p_password, stored) then
    return uid;
  end if;

  return null;
end;
$$;

-- Establecer clave de bloqueo de la app (hash bcrypt)
create or replace function public.set_user_lock(p_user_id uuid, p_lock text) returns void language plpgsql security definer as $$
begin
  update public.profiles
  set lock_key_hash = crypt(p_lock, gen_salt('bf'))
  where id = p_user_id;
end;
$$;

-- Verificar clave de bloqueo para un usuario
create or replace function public.verify_user_lock(p_user_id uuid, p_lock text) returns boolean language plpgsql security definer as $$
declare
  stored text;
begin
  select lock_key_hash into stored from public.profiles where id = p_user_id;
  if stored is null then
    return false;
  end if;
  if stored = crypt(p_lock, stored) then
    return true;
  end if;
  return false;
end;
$$;

-- Índice para búsquedas por username ya existe como constraint UNIQUE en profiles.username.
